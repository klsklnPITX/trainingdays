<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Challenge 1: Docker 101 | Azure Developer College</title>
    <meta name="generator" content="VuePress 1.6.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/trainingdays/assets/css/0.styles.b2170ae1.css" as="style"><link rel="preload" href="/trainingdays/assets/js/app.d5b0c7b2.js" as="script"><link rel="preload" href="/trainingdays/assets/js/2.d193ccda.js" as="script"><link rel="preload" href="/trainingdays/assets/js/70.7cd86c9d.js" as="script"><link rel="prefetch" href="/trainingdays/assets/js/10.67c160c1.js"><link rel="prefetch" href="/trainingdays/assets/js/11.72a1cc0e.js"><link rel="prefetch" href="/trainingdays/assets/js/12.9a53b9c0.js"><link rel="prefetch" href="/trainingdays/assets/js/13.f485a8b7.js"><link rel="prefetch" href="/trainingdays/assets/js/14.c8a2d557.js"><link rel="prefetch" href="/trainingdays/assets/js/15.2344745e.js"><link rel="prefetch" href="/trainingdays/assets/js/16.2dba3dc8.js"><link rel="prefetch" href="/trainingdays/assets/js/17.898ac6c2.js"><link rel="prefetch" href="/trainingdays/assets/js/18.c385c1dc.js"><link rel="prefetch" href="/trainingdays/assets/js/19.940c0806.js"><link rel="prefetch" href="/trainingdays/assets/js/20.ec9efb1d.js"><link rel="prefetch" href="/trainingdays/assets/js/21.f2cd341d.js"><link rel="prefetch" href="/trainingdays/assets/js/22.eb03fe7a.js"><link rel="prefetch" href="/trainingdays/assets/js/23.81b99427.js"><link rel="prefetch" href="/trainingdays/assets/js/24.e7ce36a3.js"><link rel="prefetch" href="/trainingdays/assets/js/25.31d0a173.js"><link rel="prefetch" href="/trainingdays/assets/js/26.4f40f0f3.js"><link rel="prefetch" href="/trainingdays/assets/js/27.794ebcce.js"><link rel="prefetch" href="/trainingdays/assets/js/28.73d08b43.js"><link rel="prefetch" href="/trainingdays/assets/js/29.7cc71b70.js"><link rel="prefetch" href="/trainingdays/assets/js/3.9c4ba6fd.js"><link rel="prefetch" href="/trainingdays/assets/js/30.a39812d2.js"><link rel="prefetch" href="/trainingdays/assets/js/31.718a432b.js"><link rel="prefetch" href="/trainingdays/assets/js/32.36027fec.js"><link rel="prefetch" href="/trainingdays/assets/js/33.c6f2c1a2.js"><link rel="prefetch" href="/trainingdays/assets/js/34.9e10be9f.js"><link rel="prefetch" href="/trainingdays/assets/js/35.0b6f8143.js"><link rel="prefetch" href="/trainingdays/assets/js/36.59329508.js"><link rel="prefetch" href="/trainingdays/assets/js/37.95357cee.js"><link rel="prefetch" href="/trainingdays/assets/js/38.5ea75242.js"><link rel="prefetch" href="/trainingdays/assets/js/39.88f1f1a0.js"><link rel="prefetch" href="/trainingdays/assets/js/4.7127bc0f.js"><link rel="prefetch" href="/trainingdays/assets/js/40.9796f4b5.js"><link rel="prefetch" href="/trainingdays/assets/js/41.e86cd474.js"><link rel="prefetch" href="/trainingdays/assets/js/42.29e69a93.js"><link rel="prefetch" href="/trainingdays/assets/js/43.d90b1d62.js"><link rel="prefetch" href="/trainingdays/assets/js/44.669f08a4.js"><link rel="prefetch" href="/trainingdays/assets/js/45.75c3a7f6.js"><link rel="prefetch" href="/trainingdays/assets/js/46.a34b68ee.js"><link rel="prefetch" href="/trainingdays/assets/js/47.4d395e5f.js"><link rel="prefetch" href="/trainingdays/assets/js/48.454c5344.js"><link rel="prefetch" href="/trainingdays/assets/js/49.02f3363f.js"><link rel="prefetch" href="/trainingdays/assets/js/5.409afd20.js"><link rel="prefetch" href="/trainingdays/assets/js/50.af75c209.js"><link rel="prefetch" href="/trainingdays/assets/js/51.97fe1d75.js"><link rel="prefetch" href="/trainingdays/assets/js/52.dcda9a68.js"><link rel="prefetch" href="/trainingdays/assets/js/53.003bf84b.js"><link rel="prefetch" href="/trainingdays/assets/js/54.62e34f71.js"><link rel="prefetch" href="/trainingdays/assets/js/55.9a801657.js"><link rel="prefetch" href="/trainingdays/assets/js/56.e85ebf52.js"><link rel="prefetch" href="/trainingdays/assets/js/57.727dde6e.js"><link rel="prefetch" href="/trainingdays/assets/js/58.3a1b26b1.js"><link rel="prefetch" href="/trainingdays/assets/js/59.a96ff538.js"><link rel="prefetch" href="/trainingdays/assets/js/6.299e2302.js"><link rel="prefetch" href="/trainingdays/assets/js/60.f1d2c5f4.js"><link rel="prefetch" href="/trainingdays/assets/js/61.04124f07.js"><link rel="prefetch" href="/trainingdays/assets/js/62.daaabae4.js"><link rel="prefetch" href="/trainingdays/assets/js/63.c3ac4497.js"><link rel="prefetch" href="/trainingdays/assets/js/64.39bac290.js"><link rel="prefetch" href="/trainingdays/assets/js/65.958ec7f1.js"><link rel="prefetch" href="/trainingdays/assets/js/66.1a1c6782.js"><link rel="prefetch" href="/trainingdays/assets/js/67.c3d23971.js"><link rel="prefetch" href="/trainingdays/assets/js/68.21fc5c8d.js"><link rel="prefetch" href="/trainingdays/assets/js/69.bf625936.js"><link rel="prefetch" href="/trainingdays/assets/js/7.b4b76ad9.js"><link rel="prefetch" href="/trainingdays/assets/js/71.36cfe2c7.js"><link rel="prefetch" href="/trainingdays/assets/js/72.8d76e2a1.js"><link rel="prefetch" href="/trainingdays/assets/js/73.2d5f43ad.js"><link rel="prefetch" href="/trainingdays/assets/js/74.11628563.js"><link rel="prefetch" href="/trainingdays/assets/js/75.54800e63.js"><link rel="prefetch" href="/trainingdays/assets/js/8.5d78ef56.js"><link rel="prefetch" href="/trainingdays/assets/js/9.0864e018.js">
    <link rel="stylesheet" href="/trainingdays/assets/css/0.styles.b2170ae1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/trainingdays/" class="home-link router-link-active"><!----> <span class="site-name">Azure Developer College</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/azuredevcollege/trainingdays" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/azuredevcollege/trainingdays" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/trainingdays/" aria-current="page" class="sidebar-link">Home</a></li><li><a href="/trainingdays/day1/" class="sidebar-link">Day 1 Azure Fundamentals &amp; Infrastructure</a></li><li><a href="/trainingdays/day2/" class="sidebar-link">Day 2 Azure Development</a></li><li><a href="/trainingdays/day3/" class="sidebar-link">Day 3 Data and AI</a></li><li><a href="/trainingdays/day4/" class="sidebar-link">Day 4 Azure DevOps</a></li><li><a href="/trainingdays/day5/" class="sidebar-link">Day 5 Identity and Architecture</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="challenge-1-docker-101"><a href="#challenge-1-docker-101" class="header-anchor">#</a> Challenge 1: Docker 101</h1> <h2 id="here-is-what-you-ll-learn"><a href="#here-is-what-you-ll-learn" class="header-anchor">#</a> Here is what you'll learn</h2> <ul><li>Docker Cli</li> <li>Creating and running docker containers</li> <li>Listing Docker containers and other objects</li> <li>Docker object names and ids</li> <li>Inspecting container details</li></ul> <p>In this challenge we start to learn &quot;How to use Docker CLI?&quot; and after that we'll run our first Docker Container. By the end of the challenge, we have learned very basics of Docker containers, how to create-run-stop-delete-inspect-list them.</p> <h2 id="exercises"><a href="#exercises" class="header-anchor">#</a> Exercises</h2> <p><strong>1: First let's check the current status of the Docker.</strong></p> <p>Open your terminal and type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker version
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Client: Docker Engine - Community
 Version:           <span class="token number">19.03</span>.8
 API version:       <span class="token number">1.40</span>
 Go version:        go1.12.17
 Git commit:        afacb8b7f0
 Built:             Wed Mar <span class="token number">11</span> 01:25:46 <span class="token number">2020</span>
 OS/Arch:           linux/amd64
 Experimental:      <span class="token boolean">false</span>

Server: Docker Engine - Community
 Engine:
  Version:          <span class="token number">19.03</span>.8
  API version:      <span class="token number">1.40</span> <span class="token punctuation">(</span>minimum version <span class="token number">1.12</span><span class="token punctuation">)</span>
  Go version:       go1.12.17
  Git commit:       afacb8b
  Built:            Wed Mar <span class="token number">11</span> 01:29:16 <span class="token number">2020</span>
  OS/Arch:          linux/amd64
  Experimental:     <span class="token boolean">false</span>
 containerd:
  Version:          v1.2.13
  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429
 runc:
  Version:          <span class="token number">1.0</span>.0-rc10
  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd
 docker-init:
  Version:          <span class="token number">0.18</span>.0
  GitCommit:        fec3683
</code></pre></div><p>If you've got similar output, this means that your Docker installation is successful and your cli client can communicate with Docker daemon without any problem. This output also shows us Docker's installed cli and daemon versions and their details. In case of you get <code>Error response from daemon: open \\.\pipe\docker_engine_linux: The system cannot find the file specified.</code> this means that your cli client can't connect to the daemon and probably the reason is that Docker daemon didn't started properly. Just try to start the daemon process and retry again.</p> <hr> <p><strong>2: It's time to get more information about our Docker installation.</strong></p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker info
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Client:
 Debug Mode: <span class="token boolean">false</span>

Server:
 Containers: <span class="token number">0</span>
  Running: <span class="token number">0</span>
  Paused: <span class="token number">0</span>
  Stopped: <span class="token number">0</span>
 Images: <span class="token number">0</span>
 Server Version: <span class="token number">19.03</span>.8
 Storage Driver: overlay2
  Backing Filesystem: <span class="token operator">&lt;</span>unknown<span class="token operator">&gt;</span>
  Supports d_type: <span class="token boolean">true</span>
  Native Overlay Diff: <span class="token boolean">true</span>
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Plugins:
  Volume: <span class="token builtin class-name">local</span>
  Network: bridge <span class="token function">host</span> ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file <span class="token builtin class-name">local</span> logentries splunk syslog
 <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
</code></pre></div><p>This command displays system wide information regarding the Docker installation. Information displayed includes the kernel version, number of containers and images. At the moment, we don't have any running, paused or stopped containers on our system. Also we don't have any container images pulled. This will change in a few minutes. But before running our first Docker container, let's learn &quot;how to use Docker cli?&quot;</p> <hr> <p><strong>3: Let's see &quot;How to become a Docker Cli master?&quot;</strong></p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Management Commands:
  app*        Docker Application <span class="token punctuation">(</span>Docker Inc., v0.8.0<span class="token punctuation">)</span>
  builder     Manage builds
  buildx*     Build with BuildKit <span class="token punctuation">(</span>Docker Inc., v0.3.1-tp-docker<span class="token punctuation">)</span>
  <span class="token punctuation">[</span>…<span class="token punctuation">]</span>

Commands:
  attach      Attach <span class="token builtin class-name">local</span> standard input, output, and error streams to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container's changes
  <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
</code></pre></div><p>Docker cli is fairly simple to figure out how to use. You just type <code>docker</code> and after that  type the command that you want to execute + options that you want to use. For example, simple Docker command to run a container is <code>docker run hello-world</code>. This will create a container by hello-world Docker image. <code>docker run --name azuredevcol hello-world</code> this will create another container using the same image but this time container will have a name &quot;azuredevcol&quot;. You see, it's quite simple. But it got complicated day after day. Docker had roughly 40 top-level solo commands like run, inspect, build, attach etc. While these commands worked very well but they had a few issues and Docker decided to solve these issues by introducing the management commands.</p> <p>Docker started to group the commands logically into management commands with Docker Cli version 1.13. Each group represents a single Docker object or ability. For example all container related Docker commands grouped together under container management command. Going back to the previous example, simple Docker command to run a container was <code>docker run hello-world</code>. Now it's <code>docker container run hello-world</code>. Docker cli is backward-compatible so it still supports old way of cli but management command approach is the future. Long story short, Docker cli syntax is fairly simple. Just type <code>docker</code> and after that type the management command of the object that you want to play, like <code>image</code>, <code>container</code>, <code>volume</code> and after that type the command that you want to execute, like <code>run</code>, <code>stop</code>, <code>pull</code>, <code>inspect</code> + options that you want to use. Couple of examples:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run --name container1 ubuntu <span class="token function">ping</span> <span class="token number">10.0</span>.0.1

$ docker image pull mysql:5.7

$ docker volume create my_first_volume

$ docker network inspect bridge
</code></pre></div><p>But how do we know which commands we can use and which options do we have? Simple. Just by asking for help to Docker Cli. Let's say that we want to create our first Docker container but we don't know which commands and options that we can use. We can ask this to Docker cli simply using <code>--help</code> option.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container --help
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Usage:  docker container COMMAND

Manage containers

Commands:
  attach      Attach <span class="token builtin class-name">local</span> standard input, output, and error streams to a running container
  commit      Create a new image from a container<span class="token string">'s changes
  cp          Copy files/folders between a container and the local filesystem
  […]
  rm          Remove one or more containers
  run         Run a command in a new container
  start       Start one or more stopped containers
  […]

Run '</span>docker container COMMAND --help' <span class="token keyword">for</span> <span class="token function">more</span> information on a command.
</code></pre></div><p><code>--help</code> option listed all the sub-commands under the container management command. Now we know which commands do we have and what are they used for. We can even go further and ask for help for the sub-commands. For example.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run --help
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Usage:  docker container run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> IMAGE <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span>

Run a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a new container

Options:
      --add-host list                  Add a custom host-to-IP mapping
                                       <span class="token punctuation">(</span>host:ip<span class="token punctuation">)</span>
  -a, --attach list                    Attach to STDIN, STDOUT or STDERR
      --blkio-weight uint16            Block IO <span class="token punctuation">(</span>relative weight<span class="token punctuation">)</span>,
                                       between <span class="token number">10</span> and <span class="token number">1000</span>, or <span class="token number">0</span> to
                                       disable <span class="token punctuation">(</span>default <span class="token number">0</span><span class="token punctuation">)</span>
      --blkio-weight-device list       Block IO weight <span class="token punctuation">(</span>relative device
                                       weight<span class="token punctuation">)</span> <span class="token punctuation">(</span>default <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>…<span class="token punctuation">]</span>
</code></pre></div><p>We have learned how can we use Docker Cli and how can we get help when we stuck. We're now ready to play with Docker.</p> <hr> <p><strong>4: It's time to run our first container</strong></p> <p>In a few seconds, we'll create our first Docker container. We'll create our container from Docker image tagged hello-world. Let's first check if this image is already available on our system.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image <span class="token function">ls</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</code></pre></div><p>List is empty. We don't have any Docker image locally. Let's pull first image to the system.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image pull hello-world
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Using default tag: latest
latest: Pulling from library/hello-world
0e03bdcc26d7: Pull complete
Digest: sha256:49a1c8800c94df04e9658809b006fd8a686cab8028d33cfba2cc049724254202
Status: Downloaded newer image <span class="token keyword">for</span> hello-world:latest
docker.io/library/hello-world:latest
</code></pre></div><p>Docker started to do its magic. We requested from Docker that &quot;hey please find the image called <code>hello-world</code> and pull it into this system from wherever it is located.&quot; Docker did that. Docker pulled the image from it's default &quot;Image Registry&quot; which is called Docker Hub. By default, if you don't specify the image registry url that your image is located &quot;i.e. mcr.microsoft.com/mcr/hello-world&quot;, Docker assumes that it's stored at Docker Hub &quot;docker.io/library/hello-world&quot;. We also wanted to pull image called &quot;hello-world&quot; but as can be seen from the output Docker pulled the image called  &quot;Status: Downloaded newer image for <strong>hello-world:latest</strong>&quot;. What's that <strong>:latest</strong>?
An image name is made up of slash-separated name components and tags, optionally prefixed by a registry hostname. Registry hostname represents that in which registry that image is located. Slash-separated name components represent the repository of the image in that image registry. Last part, which is called tag represents the version of the image. It's meta-data you can use to distinguish versions of your Docker images. <strong>:latest</strong> is the default tag used by Docker. If it's not tagged otherwise, images are tagged as latest by default. And if you don't specify the tag while working with docker image, docker always assumes that you're pointing the image tagged as  :latest.</p> <p>Let's type <code>docker image ls</code> one more time.</p> <div class="language-shell extra-class"><pre class="language-shell"><code>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        <span class="token number">6</span> months ago        <span class="token number">13</span>.3kB
</code></pre></div><p>hello-world:latest image has been pulled into our system. Now we're ready to create and run our first Docker container.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run hello-world
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Hello from Docker<span class="token operator">!</span>
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 <span class="token number">1</span>. The Docker client contacted the Docker daemon.
 <span class="token number">2</span>. The Docker daemon pulled the <span class="token string">&quot;hello-world&quot;</span> image from the Docker Hub.
    <span class="token punctuation">(</span>amd64<span class="token punctuation">)</span>
 <span class="token number">3</span>. The Docker daemon created a new container from that image <span class="token function">which</span> runs the
    executable that produces the output you are currently reading.
 <span class="token number">4</span>. The Docker daemon streamed that output to the Docker client, <span class="token function">which</span> sent it
    to your terminal.

To try something <span class="token function">more</span> ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu <span class="token function">bash</span>

Share images, automate workflows, and <span class="token function">more</span> with a <span class="token function">free</span> Docker ID:
 https://hub.docker.com/

For <span class="token function">more</span> examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre></div><p>Congratulations. You have created your first Docker container just now. But what has actually happened behind the scene?</p> <p>You typed the command <code>docker container run hello-world</code> and instructed to Docker daemon that you wanted to create a new container by the image called hello-world and run a command inside that container.</p> <ul><li>Docker cli took your command and connected to Docker daemon over its rest api and passed that command.</li> <li>Docker daemon checked if the image called <code>hello-world:latest</code> is stored locally or not. If it couldn't find the image, it would start to pull that from its registry. But we already pulled the image a few min ago so it didn't.</li> <li>Docker created a new container from that image. Assigned a random id to that container object. Also it assigned a random name too because we didn't specify any name for this container. After that the container has been created. But it's just created. Docker didn't start the container. &quot;btw couple of other things have also happened like r/w layer, networks etc. but we'll come to these details later&quot;</li> <li>Actually <code>docker container run</code> command means that we want to run a command inside a new container. If don't specified which command to run, Docker runs the default command instructed on the image. In our case, we didn't specify any command to run inside to container. Therefore Docker started the container that it created and ran the default command instructed on the image which is <code>/hello</code>. &quot;hello&quot; is a console application. When you run that, it shows the &quot;Hello from Docker! This message shows ...&quot; message on the console and exits.</li> <li>Unless otherwise stated, Docker attaches to the container's shell and shows the output of that shell &quot;stdout, stderr&quot;  on your console. That was the case for us too. So we saw the output of &quot;hello&quot; application on our terminal.</li> <li><strong>Golden Rule:</strong> Each Docker image has a default application-command instructed on the image to run when a container is created from that image. You can overwrite this command and point another command to run when the container is created. Docker starts a container and execute that command and also starts to monitor the process which has triggered by this command. &quot;in our case, it's 'hello' console application&quot;. This application is always the PID1.  Docker monitors the PID1. If PID1 continues to run, container runs. When PID1 killed or stopped, container exits. In our case, hello-world is a console application. When we Docker ran it, it created a message and closed. It isn't something like long running service etc. When Docker detected that the PID1 is not running any more, it closed the container too.</li></ul> <p>Let's turn back to terminal type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container <span class="token function">ls</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre></div><p><code>docker container ls</code> or short <code>docker ps</code> command list the running container on our system. At the moment, we don't have any running container on our system so list is empty. But if we type with <code>-a</code> option we can list all both running and stopped containers. Let's do that and type <code>docker ps -a</code></p> <p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
93a266670eb8        hello-world         <span class="token string">&quot;/hello&quot;</span>            <span class="token number">56</span> minutes ago      Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">56</span> minutes ago                       amazing_wu
</code></pre></div><p>Now we saw our container on the list. ID and name sections are different on your system than this output. When Docker containers are created, the system automatically assigns a universally unique identifier (UUID) number to each container. Also that is the case for each Docker object &quot;image, container, volume etc.&quot;. Each Docker object has a universally unique identifier. Those are 64 character SHA-256 IDs. Docker commands truncate them to 12 characters and that's the reason why we just saw the first 12 characters of the ID. In addition to that, Docker assigns names to the containers. If we don't specify the name with <code>--name</code> option, Docker generates a random name using an open source list of adjectives and known figures in science and IT world.
We can use those IDs and names interchangeable when we call the container and we'll see the examples in a few minutes.
Other sections on that list are Image, Command, Created, Status and Ports. Image is the image that used to create this container. Command is the command that has executed in the container when we started. Created is the timestamp of the creation time. Status is the current status of the container and in our case it's &quot;Exited&quot; which means container is stopped. Ports section show us the exposed ports from that container but it's empty at the moment because we didn't expose any port.</p> <p>Let's continue to play with this container. We created the container, it ran the &quot;hello&quot; application, application closed so the container too. Let's start that container again. We will use container id as a reference in this.</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container start 93a <span class="token comment"># just first a few characters of the container id would be enough</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>93a
</code></pre></div><p>This time it didn't show us the output. Instead of that, Docker returned the container id that we typed. When we used the <code>docker container run</code> command our console attached to the container's shell and we saw the output. But with <code>docker container start</code> this doesn't happen. <code>docker container start</code> starts the stopped container and reruns the default command. In our case, it started the &quot;hello&quot; console application again. &quot;hello&quot; console application recreated the message and send it to the &quot;stdout&quot; stream of the console's shell. We didn't attach to that shell so we didn't see the output. But output is there. We can see any generated out put of the container's console by <code>docker logs</code> command. Let's do that but this time let's use the container's name instead of the id.</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker logs amazing_wu <span class="token comment">#name of the container</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Hello from Docker<span class="token operator">!</span>
This message shows that your installation appears to be working correctly.
<span class="token punctuation">[</span>…<span class="token punctuation">]</span>
Hello from Docker<span class="token operator">!</span>
This message shows that your installation appears to be working correctly.
<span class="token punctuation">[</span>…<span class="token punctuation">]</span>
</code></pre></div><p>We saw 2 messages. By default, <code>docker logs</code> shows the command’s output just as it would appear if you ran the command interactively in a terminal. UNIX and Linux commands typically open three I/O streams when they run, called STDIN, STDOUT, and STDERR. STDIN is the command’s input stream, which may include input from the keyboard or input from another command. STDOUT is usually a command’s normal output, and STDERR is typically used to output error messages. By default, <code>docker logs</code> shows the STDOUT and STDERR streams of the container since it was created. Our container wasn't killed. When we first ran the container, it was stopped automatically when it's PID1 stopped. We started the container one more time with <code>docker container start</code> command again. Process restarted, generated the message and stopped again. Container was stopped too. But it wasn't killed. So we can still see all the STDOUT and STDERR messages since the creation of the container. But now it's time to kill &quot;or delete&quot; the container.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container <span class="token function">rm</span> 93a <span class="token comment"># or container name</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>93a
</code></pre></div><p>If you type <code>docker ps -a</code> now, output should be empty.</p> <p><strong>5: Detach container</strong></p> <p>We're gonna create another container from the same hello-world image. But this time we'll create it detached. By default Docker container starts in the foreground mode. Like the one that we created above. In the foreground mode, Docker starts the default process in the container and attaches your console to the process’s STDIN, STDOUT and STDERR streams. But when we do that,  you can not access your console anymore. You just see the output generated by container on your screen. To avoid this we can start a container in the background mode which is also called detached and the option that gives you this ability is <code>-d</code>. Running a container in the foreground or background doesn't change it's behavior. This is just about if we want to attach to the containers streams or not. Let's create the container in the background and also this time let's define its name too.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run -d --name azuredevcol hello-world
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>12fe24372acd0fed5f2063d35faaae13f2cb2e5f7d60f94ff86bec55ba272b1a
</code></pre></div><p>This time, instead of getting the message generated by hello app, Docker returned the container id back. Literally same thing has happened. A new container has been created using hello-world image, container has been started, default application inside the container started, it did its thing, app stopped so container stopped too. If you type <code>docker logs azuredevcol</code> , you can see the logs generated by the application running inside the container. Now let's create another container but we'll use another image <code>httpd</code> which is the official Apache HTTP Server Docker image.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run -d --name webserver httpd
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Unable to <span class="token function">find</span> image <span class="token string">'httpd:latest'</span> locally
latest: Pulling from library/httpd
6ec8c9369e08: Pull complete
819d6e0b29e7: Pull complete
6a237d0d4aa4: Pull complete
cd9a987eec32: Pull complete
fdec8f3f8485: Pull complete
Digest: sha256:2a9ae199b5efc3e818cdb41c790638fc043ffe1aba6bc61ada28ab6356d044c6
Status: Downloaded newer image <span class="token keyword">for</span> httpd:latest
83d3a7cb8bd571d9f35688d80a4c676b3fe88f297d2170c5ea78d1c87dcd31aa
</code></pre></div><p>We requested from Docker that, create a new container by using httpd image, start it detached and gave it the name &quot;webserver&quot;. Docker took our command, checked the local image store and couldn't find the image called httpd. It started to pull the image from Docker Hub. As you can see from the output, it completed this pulling process in 5 steps. Docker pulled 5 different layers. We'll come to this layer thing later but for now just notice that this operation was handled as multiple steps. At the end, Docker combined these layers and save them to the local store and returned us back the id of the image. After that Docker create the container and ran it and returned us back the container id. And also it gave us our console back because we started the container in the detached mode.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker <span class="token function">ps</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES
83d3a7cb8bd5        httpd               <span class="token string">&quot;httpd-foreground&quot;</span>   <span class="token number">12</span> seconds ago      Up <span class="token number">12</span> seconds       <span class="token number">80</span>/tcp              webserver
</code></pre></div><p>As you can see from the output, status of the container is &quot;Up&quot; and the main process that is running inside the container is &quot;httpd-foreground&quot;. httpd-foreground is Apache's web server daemon. It's not like the one shot hello-app. It's a service, a daemon. When you start it, it continues to run until it crashes or explicitly stopped or killed. It's running at the moment so our container too. Remember the Golden Rule. If the first process inside the container runs, container runs too. If it stops, container stops too. Let's try to delete this container.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container <span class="token function">rm</span> webserver
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Error response from daemon: You cannot remove a running container 83d3a7cb8bd571d9f35688d80a4c676b3fe88f297d2170c5ea78d1c87dcd31aa. Stop the container before attempting removal or force remove
</code></pre></div><p>As message says, you can't delete a running container. Either you have to stop the container first or you can force the deletion with <code>-f</code> option. Type <code>docker container rm -f webserver</code> to delete the container.</p> <p><strong>6: Running another application inside the container</strong></p> <p>As mentioned before &quot;Each Docker image has a default application-command instructed on the image to run when a container is created from that image. You can overwrite this command and point another command to run when the container is created&quot;. Let's try that one. Again we'll create a container from httpd image but this time we'll create it to run another application instead of the default &quot;httpd-foreground&quot;.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run httpd <span class="token function">date</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Tue May <span class="token number">28</span> <span class="token number">20</span>:46:22 UTC <span class="token number">2020</span>
</code></pre></div><p>We requested from Docker to create a new container from <code>httpd</code> image and run <code>date</code> command instead of the default &quot;httpd-foreground&quot;.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker <span class="token function">ps</span> -a
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
42227d141918        httpd               <span class="token string">&quot;date&quot;</span>              <span class="token number">4</span> seconds ago       Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">2</span> seconds ago                       sad_yonath
</code></pre></div><p>As you can see, Docker did that and created a new container and ran the date application in it. You can also execute-run other commands-applications inside the running containers too. <code>docker container exec</code> command does that. Let's try that. First we're gonna create a running container.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run -d --name exec_test httpd
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>d0f1c26b80706f47ba4d676e285c771d7ed5c077c961be36dc73091893a784a9
</code></pre></div><p>Check and confirm that the container is running.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker <span class="token function">ps</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>CONTAINER ID        IMAGE               COMMAND              CREATED              STATUS              PORTS               NAMES
d0f1c26b8070        httpd               <span class="token string">&quot;httpd-foreground&quot;</span>   About a minute ago   Up About a minute   <span class="token number">80</span>/tcp              exec_test
</code></pre></div><p>Now we have a running container. We can execute new commands inside that container.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container <span class="token builtin class-name">exec</span> exec_test <span class="token function">date</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Tue May <span class="token number">28</span> <span class="token number">21</span>:16:03 UTC <span class="token number">2020</span>
</code></pre></div><p>You can run any application-command if the application exists inside the container. Let's delete the container before the next challenge.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container <span class="token function">rm</span> -f exec_test
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>exec_test
</code></pre></div><p><strong>7: Connect to a Docker container</strong></p> <p>As the last exercise of this challenge, we're gonna connect to a running container. Connecting to a running Docker container is helpful when you want to see what is happening inside the container. First let's create a running container.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run -d --name azuredevcol httpd
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>3e9574a7ed458ff1d2343404a1c24f3361f18f1dabf52a75da0d0b4030723c82
</code></pre></div><p>Check and confirm that the container is running.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker <span class="token function">ps</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES
3e9574a7ed45        httpd               <span class="token string">&quot;httpd-foreground&quot;</span>   <span class="token number">7</span> seconds ago       Up <span class="token number">7</span> seconds        <span class="token number">80</span>/tcp              azuredevcol
</code></pre></div><p>Now we have a running container named azuredevcol. We want to connect to this container's shell. Don't confuse. We won't attach to this container's running process' STDOUT and STDERR streams. We want to run a shell inside the container and attach to that shell. To be able to that, we're gonna use <code>docker container exec</code> command. But this time we need 2 options, which are <code>--interactive --tty</code> . But we combine and use them as <code>-it</code>. Interactive means that you want to keep the input channel open on the container and tty means that you're creating pseudo terminal. Long story short <code>-it</code> tells Docker to allocate pseudo-TTY connected to the container’s stdin, creating an interactive shell in the container.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker <span class="token builtin class-name">exec</span> -it azuredevcol <span class="token function">sh</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#</span>
</code></pre></div><p>Our shell prompt changed to <code>#</code> and this means that we're connected to container. We executed the <code>sh</code> command inside the running container with <code>-it</code> options. This allowed us to connect a running sh instance inside the container. Let's type couple of commands to proof that we're in the container.</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># echo $0</span>
<span class="token function">sh</span>
<span class="token comment"># ls</span>
bin  build  cgi-bin  conf  error  htdocs  icons  include  logs  modules
<span class="token comment"># date</span>
Tue May <span class="token number">28</span> <span class="token number">21</span>:44:53 UTC <span class="token number">2020</span>
<span class="token comment"># hostname</span>
3e9574a7ed45
<span class="token comment"># exit</span>
$
</code></pre></div><p>You can delete the container by typing <code>docker container rm -f azuredevcol</code>.
Also <code>docker container prune</code> command deletes all stopped container as bulk but use it with awareness.</p> <p><strong>8: Inspecting a container's details</strong></p> <p><code>docker ps</code> or <code>docker container ls</code> commands show us the list of running containers on the system and when you add <code>-a</code> option you can list both running and stopped containers. But the output of these commands give you very brief details about the containers. When you want to get all the information related to a specific container, you should use <code>docker container inspect</code> command. Let's try this. First let's create a container.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run -d --name inspect_test httpd
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>d4463417f9946f9d2cabfdca5ac81f45b7d2a2f4dc8299b9d36922b8d4b23111
</code></pre></div><p>with inspect command we can see all the details of this or any container.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container inspect inspect_test
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token string">&quot;Id&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;d4463417f9946f9d2cabfdca5ac81f45b7d2a2f4dc8299b9d36922b8d4b23111&quot;</span>,
        <span class="token string">&quot;Created&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;2020-07-31T08:38:26.3847773Z&quot;</span>,
        <span class="token string">&quot;Path&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;httpd-foreground&quot;</span>,
        <span class="token string">&quot;Args&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,
        <span class="token string">&quot;State&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
            <span class="token string">&quot;Status&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;running&quot;</span>,
            <span class="token string">&quot;Running&quot;</span><span class="token builtin class-name">:</span> true,
            <span class="token string">&quot;Paused&quot;</span><span class="token builtin class-name">:</span> false,
            <span class="token string">&quot;Restarting&quot;</span><span class="token builtin class-name">:</span> false,
            <span class="token string">&quot;OOMKilled&quot;</span><span class="token builtin class-name">:</span> false,
            <span class="token string">&quot;Dead&quot;</span><span class="token builtin class-name">:</span> false,
            <span class="token string">&quot;Pid&quot;</span><span class="token builtin class-name">:</span> <span class="token number">1085</span>,
            <span class="token string">&quot;ExitCode&quot;</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">&quot;Error&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>,
            <span class="token string">&quot;StartedAt&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;2020-07-31T08:38:27.3829639Z&quot;</span>,
            <span class="token string">&quot;FinishedAt&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;0001-01-01T00:00:00Z&quot;</span>
        <span class="token punctuation">}</span>,
        <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
        <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
        <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
        <span class="token string">&quot;Image&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;sha256:9d2a0c6e5b5714303c7b72793311d155b1652d270a785c25b88197069ba78734&quot;</span>,

                    <span class="token string">&quot;MacAddress&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;02:42:ac:11:00:02&quot;</span>,
                    <span class="token string">&quot;DriverOpts&quot;</span><span class="token builtin class-name">:</span> null
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><p>You can delete the container by typing <code>docker container rm -f inspect_test</code>.
Also <code>docker container prune</code> command deletes all stopped container as bulk but use it with awareness.</p> <h2 id="wrap-up"><a href="#wrap-up" class="header-anchor">#</a> Wrap up</h2> <p><strong>Congratulations</strong> you have completed the Docker 101 challenge. You've just learned the very basics of Docker containers.</p> <p>*** Reference: https://docs.docker.com</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/azuredevcollege/trainingdays/edit/master/day6/challenges/challenge1.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/trainingdays/assets/js/app.d5b0c7b2.js" defer></script><script src="/trainingdays/assets/js/2.d193ccda.js" defer></script><script src="/trainingdays/assets/js/70.7cd86c9d.js" defer></script>
  </body>
</html>
